{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4ba75cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Script to attempt inhomogeneous fits for binary classification of mutation-acyclicity on rank 4 quivers'''\n",
    "#Import libraries\n",
    "import numpy as np\n",
    "from itertools import permutations\n",
    "from github.Theorem_2_8.ProofFunctions import *\n",
    "#Import sklearn requirements\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.preprocessing import PolynomialFeatures\n",
    "from sklearn.pipeline import make_pipeline\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import accuracy_score, matthews_corrcoef\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb0c3ac6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# a) Import mutation-class data\n",
    "MA_large, NMA_large = [], []\n",
    "with open('./MA_ALL_DEPTH_7_TYPE_0.txt','r') as file:\n",
    "    for line in file.readlines():\n",
    "        MA_large.append(list(eval(line)))\n",
    "with open('./NMA_ALL_DEPTH_5__TYPE_1.txt','r') as file:\n",
    "    for line in file.readlines():\n",
    "        NMA_large.append(list(eval(line)))\n",
    "MA_large = np.array(MA_large).reshape(-1,4,4)\n",
    "NMA_large = np.array(NMA_large).reshape(-1,4,4)\n",
    "\n",
    "#Convert to vectors\n",
    "MA_vec = MA_large[:,np.triu_indices(4, k=1)[0],np.triu_indices(4, k=1)[1]]\n",
    "NMA_vec = NMA_large[:,np.triu_indices(4, k=1)[0],np.triu_indices(4, k=1)[1]]\n",
    "\n",
    "#Take a random sample\n",
    "sample_size = 200\n",
    "MA_vec = MA_vec[np.random.choice(MA_vec.shape[0], sample_size, False), :]\n",
    "NMA_vec = NMA_vec[np.random.choice(NMA_vec.shape[0], sample_size, False), :]\n",
    "print(f'Data shapes (MA, NMA): {MA_vec.shape, NMA_vec.shape}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42650ec6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# (b) Import theorem data\n",
    "MA, NMA = [], []\n",
    "with open('../../Theorem_2_8/MA.txt','r') as file:\n",
    "    for line in file.readlines():\n",
    "        MA.append(eval(line))\n",
    "with open('../../Theorem_2_8/NMA.txt','r') as file:\n",
    "    for line in file.readlines():\n",
    "        NMA.append(eval(line))\n",
    "MA = np.array(MA)\n",
    "NMA = np.array(NMA)\n",
    "print(f'Shapes (MA, NMA): {MA.shape, NMA.shape}')\n",
    "\n",
    "#Generate full isomorphism classes\n",
    "MA_full = np.unique([matrix[np.ix_(perm, perm)] for perm in permutations(range(4)) for matrix in MA],axis=0)\n",
    "NMA_full = np.unique([matrix[np.ix_(perm, perm)] for perm in permutations(range(4)) for matrix in NMA],axis=0)\n",
    "\n",
    "#Convert data to vectors\n",
    "MA_vec = MA_full[:,np.triu_indices(4, k=1)[0],np.triu_indices(4, k=1)[1]]\n",
    "NMA_vec = NMA_full[:,np.triu_indices(4, k=1)[0],np.triu_indices(4, k=1)[1]]\n",
    "print(f'Data shapes (MA, NMA): {MA_vec.shape, NMA_vec.shape}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8fb7097d",
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################################################\n",
    "#Fit a inhomogeneous polynomial SVC\n",
    "#ML hyperparameters\n",
    "poly_max_degree = 1\n",
    "seed = 0\n",
    "test_proportion = float(0.1)\n",
    "\n",
    "#Set up data\n",
    "X = np.concatenate((MA_vec,NMA_vec),axis=0)\n",
    "Y = np.concatenate((np.zeros(MA_vec.shape[0]),np.ones(NMA_vec.shape[0])))\n",
    "X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_proportion, random_state=seed)\n",
    "\n",
    "#Build the model\n",
    "model = make_pipeline(PolynomialFeatures(poly_max_degree), SVC(kernel='linear'))\n",
    "\n",
    "# Fit the model\n",
    "model.fit(X_train, Y_train)\n",
    "\n",
    "# Evaluate the model\n",
    "Y_pred = model.predict(X_test)\n",
    "mcc = matthews_corrcoef(Y_test, Y_pred)\n",
    "print(f\"SVC MCC: {mcc:.2f}\")\n",
    "\n",
    "#Results: ...for degrees {1,2,3,4,5}: \n",
    "#a) (, )\n",
    "#b) (0, 0.46, 0.46, 0.83, 0.81)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c44a5b27",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Equation properties in the embedding space\n",
    "Coefficients = model[1].dual_coef_[0]\n",
    "SupportVectors = model[1].support_vectors_\n",
    "intercept = model[1].intercept_[0]\n",
    "print(Coefficients.shape,SupportVectors.shape,intercept.shape)\n",
    "\n",
    "gamma = 1./(X.var()*X.shape[1])\n",
    "rho = model[1].coef0\n",
    "\n",
    "#Generic decision function (hyperplane where this = 0)\n",
    "def DecisionFunction(InputVector):\n",
    "    return sum([(gamma*np.dot(SupportVectors[i], InputVector) + rho)**svm_degree * Coefficients[i] for i in range(len(Coefficients))]) + intercept\n",
    "\n",
    "#Define the generic input variables\n",
    "from sage.all import var\n",
    "variables = var('x', n=X.shape[1], latex_name='x')\n",
    "basis = [1] + [SR(i) for i in model[0].get_feature_names_out()[1:]]\n",
    "\n",
    "#Define the symbolic equation (note where this = 0 defines the hyperplane)\n",
    "equation = sum([(gamma*sum(SupportVectors[j,i]*basis[i] for i in range(len(basis)))+rho)*Coefficients[j] for j in range(len(SupportVectors))]) + intercept\n",
    "print(equation) #.full_simplify())   \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "508da0fd",
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################################################\n",
    "#Manually build the desired polynomial to test\n",
    "#0-12 1-13 2-14 3-23 4-24 5-34\n",
    "def poly_transform(vec):\n",
    "    return np.array([vec[:,0]**2, vec[:,1]**2, vec[:,2]**2, vec[:,3]**2, vec[:,4]**2, vec[:,5]**2, vec[:,0]*vec[:,2]*vec[:,4], vec[:,0]*vec[:,1]*vec[:,3], vec[:,1]*vec[:,2]*vec[:,5], vec[:,3]*vec[:,4]*vec[:,5]])\n",
    "\n",
    "#Convert vectors to polynomial terms\n",
    "MA_vec_polyform = poly_transform(MA_vec).transpose()\n",
    "NMA_vec_polyform = poly_transform(NMA_vec).transpose() \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aa9788b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "#ML hyperparameters\n",
    "seed = 0\n",
    "test_proportion = float(0.1)\n",
    "\n",
    "#Set up data\n",
    "X = np.concatenate((MA_vec_polyform,NMA_vec_polyform),axis=0)\n",
    "Y = np.concatenate((np.zeros(MA_vec_polyform.shape[0]),np.ones(NMA_vec_polyform.shape[0])))\n",
    "X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_proportion, random_state=seed)\n",
    "\n",
    "#Build the model\n",
    "diphantine_svc = SVC(kernel='linear')\n",
    "\n",
    "# Fit the model\n",
    "diphantine_svc.fit(X_train, Y_train)\n",
    "\n",
    "# Evaluate the model\n",
    "Y_pred = diphantine_svc.predict(X_test)\n",
    "mcc = matthews_corrcoef(Y_test, Y_pred)\n",
    "print(f\"SVC MCC: {mcc:.2f}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f07cb331",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Equation properties in the embedding space\n",
    "Coefficients = diphantine_svc.dual_coef_[0]\n",
    "SupportVectors = diphantine_svc.support_vectors_\n",
    "intercept = diphantine_svc.intercept_[0]\n",
    "\n",
    "gamma = 1./(X.var()*X.shape[1])\n",
    "rho = diphantine_svc.coef0\n",
    "\n",
    "#Generic decision function (hyperplane where this = 0)\n",
    "def DecisionFunction(InputVector):\n",
    "    return sum([(gamma*np.dot(SupportVectors[i], InputVector) + rho)**svm_degree * Coefficients[i] for i in range(len(Coefficients))]) + intercept\n",
    "\n",
    "#Define the generic input variables\n",
    "from sage.all import var\n",
    "variables = var('x', n=X.shape[1], latex_name='x')\n",
    "diphantine_basis = [SR('x0^2'), SR('x1^2'), SR('x2^2'), SR('x3^2'), SR('x4^2'), SR('x5^2'), SR('x0*x2*x4'), SR('x0*x1*x3'), SR('x1*x2*x5'), SR('x3*x4*x5')]\n",
    "\n",
    "#Define the symbolic equation (note where this = 0 defines the hyperplane)\n",
    "equation = sum([(gamma*sum(SupportVectors[j,i]*diphantine_basis[i] for i in range(len(diphantine_basis))) + rho)*Coefficients[j] for j in range(len(SupportVectors))]) + intercept\n",
    "print(equation) #.full_simplify())   \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "SageMath 10.0",
   "language": "sage",
   "name": "sagemath"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
